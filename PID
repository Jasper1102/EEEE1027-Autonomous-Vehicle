#include <LiquidCrystal.h> 

LiquidCrystal lcd(8, 9, 4, 5, 6, 7); 

const int PIN_ENA = 3;    
const int PIN_IN1 = A1; 
const int PIN_IN2 = A2; 
const int PIN_ENB = 11;    
const int PIN_IN3 = 13;    
const int PIN_IN4 = 12; 
const int PIN_LEFT    = A5; 
const int PIN_CENTER = A3; 
const int PIN_RIGHT   = A4; 
const int PIN_ENC_L = 2; 
const int PIN_ENC_R = 1; 

volatile unsigned long countL = 0; 
unsigned long startTime = 0;
unsigned long lastLCDUpdate = 0;
const float PULSES_PER_CM = 2.05; 
const float PAUSE_DISTANCE = 220.0; 
bool hasPaused = false; 

int BASE_SPEED = 160; 
float Kp = 35.0; 
float Kd = 60.0; 
float Ki = 0.0; 
float lastError = 0; 
float integral = 0; 
const int BLACK_STATE = LOW; 
int analogThreshold = 500; 

void setup() {
  pinMode(PIN_IN3, OUTPUT); digitalWrite(PIN_IN3, LOW); 
  pinMode(PIN_ENA, OUTPUT); pinMode(PIN_IN1, OUTPUT); pinMode(PIN_IN2, OUTPUT);
  pinMode(PIN_ENB, OUTPUT); pinMode(PIN_IN4, OUTPUT);
  pinMode(PIN_LEFT, INPUT);
  pinMode(PIN_CENTER, INPUT);
  pinMode(PIN_ENC_L, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(PIN_ENC_L), isr_Left, CHANGE);
  lcd.begin(16, 2);
  lcd.clear();
  lcd.print("V225 PID ULTRA"); 
  delay(500);
  startTime = millis();
}

void loop() {
  float distance = countL / PULSES_PER_CM;
  unsigned long currentTime = millis();
  float duration = (currentTime - startTime) / 1000.0;

  if (currentTime - lastLCDUpdate > 250) {
    lcd.setCursor(0, 0); lcd.print("D:"); lcd.print(distance, 0); lcd.print("cm    ");
    lcd.setCursor(8, 0); lcd.print("T:"); lcd.print(duration, 1);
    lastLCDUpdate = currentTime;
  }

  if (distance >= PAUSE_DISTANCE && !hasPaused) {
    stopMotors();
    lcd.clear(); lcd.print("PAUSE 3 SEC...");
    delay(3000);
    hasPaused = true; 
    lcd.clear();
    lastError = 0;
  }

  bool l = (digitalRead(PIN_LEFT) == BLACK_STATE);
  bool c = (digitalRead(PIN_CENTER) == BLACK_STATE);
  bool r = (analogRead(PIN_RIGHT) < analogThreshold);

  if (hasPaused && l && c && r) {
      setMotorSpeed(-255, -255); delay(150);
      stopMotors();
      lcd.clear();
      lcd.setCursor(0, 0); lcd.print("D:"); lcd.print(distance, 1); lcd.print("cm");
      lcd.setCursor(0, 1); lcd.print("T:"); lcd.print(duration, 1); lcd.print("s");
      while(true); 
  }

  float error = getError(l, c, r);
  float P = error;
  float I = integral + error;
  float D = error - lastError;
  float correction = (Kp * P) + (Ki * I) + (Kd * D);
   
  lastError = error;
  integral = I;

  int speedLeft = BASE_SPEED + correction;
  int speedRight = BASE_SPEED - correction;

  setMotorSpeed(speedLeft, speedRight);
}

float getError(bool l, bool c, bool r) {
    if (!l && c && !r) return 0;
    if (l && c && !r) return -1;
    if (l && !c && !r) return -2;
    if (!l && c && r) return 1;
    if (!l && !c && r) return 2;
    if (l && !c && r) return 0; 
    return lastError;
}

void setMotorSpeed(int speedL, int speedR) {
  speedL = constrain(speedL, -255, 255);
  speedR = constrain(speedR, -255, 255);

  if (speedL >= 0) {
    digitalWrite(PIN_IN1, LOW); digitalWrite(PIN_IN2, HIGH); 
    analogWrite(PIN_ENA, speedL); 
  } else {
    digitalWrite(PIN_IN1, HIGH); digitalWrite(PIN_IN2, LOW); 
    analogWrite(PIN_ENA, abs(speedL)); 
  }

  if (speedR >= 0) {
    digitalWrite(PIN_IN3, LOW); digitalWrite(PIN_IN4, HIGH); 
    analogWrite(PIN_ENB, speedR); 
  } else {
    digitalWrite(PIN_IN3, HIGH); digitalWrite(PIN_IN4, LOW); 
    analogWrite(PIN_ENB, abs(speedR)); 
  }
}

void stopMotors() {
  analogWrite(PIN_ENA, 255); 
  analogWrite(PIN_ENB, 255);
  digitalWrite(PIN_IN1, LOW); digitalWrite(PIN_IN2, LOW);
  digitalWrite(PIN_IN3, LOW); digitalWrite(PIN_IN4, LOW);
}

void isr_Left() {
  countL++;
}
